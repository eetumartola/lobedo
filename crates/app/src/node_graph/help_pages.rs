#[derive(Clone, Copy)]
pub struct NodeHelpPage {
    pub name: &'static str,
    pub description: &'static [&'static str],
    pub inputs: &'static [&'static str],
    pub outputs: &'static [&'static str],
    pub parameters: &'static [(&'static str, &'static str)],
}

pub fn node_help_page(node_name: &str) -> Option<NodeHelpPage> {
    match node_name {
        "Box" => Some(NodeHelpPage {
            name: "Box",
            description: &[
                "Creates an axis-aligned box mesh centered at the given position.",
                "Use it for blockouts, quick boolean volumes, or as a reference size in the scene.",
                "The box is generated with shared points so downstream deformers and normals behave predictably.",
            ],
            inputs: &[],
            outputs: &["out: Mesh with box primitives."],
            parameters: &[
                ("size", "Box dimensions in X/Y/Z."),
                ("center", "Box center in world space."),
            ],
        }),
        "Grid" => Some(NodeHelpPage {
            name: "Grid",
            description: &[
                "Creates a flat grid mesh on the XZ plane (Y up).",
                "It is useful as a ground plane, UV test surface, or scatter source.",
                "Rows and columns control tessellation and downstream point density.",
            ],
            inputs: &[],
            outputs: &["out: Mesh grid."],
            parameters: &[
                ("size", "Grid size in X/Z."),
                ("rows", "Rows (subdivisions) along Z."),
                ("cols", "Columns (subdivisions) along X."),
                ("center", "Grid center in world space."),
            ],
        }),
        "Sphere" => Some(NodeHelpPage {
            name: "Sphere",
            description: &[
                "Creates a UV sphere mesh with poles at top and bottom.",
                "Row/column counts control tessellation and UV seam density.",
                "Use it for placeholders, smooth shapes, or as a deformation target.",
            ],
            inputs: &[],
            outputs: &["out: Mesh sphere."],
            parameters: &[
                ("radius", "Sphere radius."),
                ("rows", "Latitude segments."),
                ("cols", "Longitude segments."),
                ("center", "Sphere center in world space."),
            ],
        }),
        "Tube" => Some(NodeHelpPage {
            name: "Tube",
            description: &[
                "Creates a vertical tube/cylinder along the Y axis.",
                "It can be capped or left open depending on your use case.",
                "Row/column counts control tessellation along height and around the circumference.",
            ],
            inputs: &[],
            outputs: &["out: Mesh tube."],
            parameters: &[
                ("radius", "Tube radius."),
                ("height", "Tube height."),
                ("rows", "Height segments."),
                ("cols", "Side segments."),
                ("capped", "Add caps at the ends."),
                ("center", "Tube center in world space."),
            ],
        }),
        "Circle" => Some(NodeHelpPage {
            name: "Circle",
            description: &[
                "Creates a circle primitive on the XZ plane.",
                "Curve mode outputs a closed polyline; Mesh mode outputs a triangulated disk.",
                "Use it as a sweep profile, a planar shape, or a curve source.",
            ],
            inputs: &[],
            outputs: &["out: Curve or mesh circle."],
            parameters: &[
                ("output", "Output mode: Curve or Mesh."),
                ("radius", "Circle radius."),
                ("segments", "Number of segments."),
                ("center", "Circle center in world space."),
            ],
        }),
        "Curve" => Some(NodeHelpPage {
            name: "Curve",
            description: &[
                "Creates a polyline curve from a list of points.",
                "Curve points live in the shared point pool so they can be edited like any other points.",
                "Subdivisions insert extra points between controls for smoother downstream results.",
            ],
            inputs: &[],
            outputs: &["out: Curve primitive referencing points."],
            parameters: &[
                ("points", "Curve points encoded as x y z; x y z; ..."),
                ("subdivs", "Subdivisions per segment for smoothing."),
                ("closed", "Close the curve loop."),
            ],
        }),
        "Sweep" => Some(NodeHelpPage {
            name: "Sweep",
            description: &[
                "Sweeps a profile curve or point list along a path curve to create a surface.",
                "The node builds an oriented frame along the path using the up vector, similar to a simple Frenet frame.",
                "If the inputs are plain point clouds, the closed flags decide whether each loop is closed.",
            ],
            inputs: &[
                "profile: Curve or mesh points to sweep.",
                "path: Curve or mesh points for the sweep path.",
            ],
            outputs: &["out: Swept polygon mesh."],
            parameters: &[
                ("profile_closed", "Close the profile if no curve primitive is supplied."),
                ("path_closed", "Close the path if no curve primitive is supplied."),
                ("up", "Up vector used to stabilize the sweep orientation."),
            ],
        }),
        "File" => Some(NodeHelpPage {
            name: "File",
            description: &[
                "Reads mesh geometry from OBJ or glTF/GLB files on disk.",
                "Positions, indices, normals, and UVs are imported when present.",
                "Materials are mapped into a primitive material attribute when available.",
            ],
            inputs: &[],
            outputs: &["out: Mesh geometry from file."],
            parameters: &[("path", "Path to an OBJ or glTF/GLB file.")],
        }),
        "Splat Read" | "Read Splats" => Some(NodeHelpPage {
            name: "Splat Read",
            description: &[
                "Loads Gaussian splats from a PLY file and produces splat primitives.",
                "The reader expects 3DGS-style fields: position, rotation (quaternion), scale (log sigma), opacity (logit), and SH coefficients.",
                "On load, values are validated and normalized so scales and opacity stay in a stable range.",
                "Full SH keeps all bands for relighting and delighting workflows.",
                "Color Only keeps just the DC color/alpha and zeros higher bands for faster loading and lower memory use.",
            ],
            inputs: &[],
            outputs: &["out: Splat geometry."],
            parameters: &[
                ("path", "Path to a splat PLY file."),
                ("read_mode", "Full SH keeps all SH bands; Color Only keeps only DC color/alpha."),
            ],
        }),
        "Splat Write" | "Write Splats" => Some(NodeHelpPage {
            name: "Splat Write",
            description: &[
                "Writes Gaussian splats to a PLY file in a 3DGS-compatible layout.",
                "The node passes geometry through; writing happens only when the Write button is pressed.",
                "On save, splats are normalized so external viewers see stable scales and opacity.",
                "Binary is faster and smaller; ASCII is useful for debugging or interchange.",
            ],
            inputs: &["in: Splat geometry to write."],
            outputs: &["out: Pass-through geometry."],
            parameters: &[
                ("path", "Output PLY file path."),
                ("format", "PLY format: Binary (recommended) or ASCII."),
            ],
        }),
        "OBJ Output" => Some(NodeHelpPage {
            name: "OBJ Output",
            description: &[
                "Exports mesh geometry to OBJ.",
                "Positions, normals, and vertex UVs are written when available.",
                "Writing is performed when the Write button is pressed.",
            ],
            inputs: &["in: Mesh geometry to write."],
            outputs: &["out: Pass-through geometry."],
            parameters: &[("path", "Output OBJ file path.")],
        }),
        "GLTF Output" => Some(NodeHelpPage {
            name: "GLTF Output",
            description: &[
                "Exports mesh geometry to glTF/GLB.",
                "The exporter includes material parameters and UVs when present.",
                "Writing is performed when the Write button is pressed.",
            ],
            inputs: &["in: Mesh geometry to write."],
            outputs: &["out: Pass-through geometry."],
            parameters: &[("path", "Output glTF/GLB file path.")],
        }),
        "Delete" => Some(NodeHelpPage {
            name: "Delete",
            description: &[
                "Deletes geometry inside a selection volume, similar to Houdini Delete.",
                "For meshes, a triangle is kept only if all its points survive the test.",
                "Works on meshes, curves, and splats; groups can restrict the operation.",
            ],
            inputs: &["in: Geometry to delete from."],
            outputs: &["out: Filtered geometry."],
            parameters: &[
                ("shape", "Selection shape: Box, Sphere, Plane, Selection, or Attribute Range."),
                ("invert", "Invert selection (delete outside instead of inside)."),
                ("center", "Shape center."),
                ("size", "Box size in X/Y/Z."),
                ("radius", "Sphere radius."),
                ("plane_origin", "Plane origin for half-space delete."),
                ("plane_normal", "Plane normal for half-space delete."),
                ("group", "Optional group to restrict deletion."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "Splat Prune" | "Prune" => Some(NodeHelpPage {
            name: "Splat Prune",
            description: &[
                "Filters splats by scale and opacity ranges in splat parameter space.",
                "Scale is stored as log-sigma per axis and opacity is stored as a logit.",
                "Use it to remove tiny, huge, or nearly invisible splats after editing.",
                "Optional invalid removal drops NaNs/Infs for stability.",
            ],
            inputs: &["in: Splat geometry."],
            outputs: &["out: Filtered splats."],
            parameters: &[
                ("min_opacity", "Minimum logit opacity to keep."),
                ("max_opacity", "Maximum logit opacity to keep."),
                ("min_scale", "Minimum log-scale (ln sigma) to keep."),
                ("max_scale", "Maximum log-scale (ln sigma) to keep."),
                ("remove_invalid", "Drop splats with NaN/Inf."),
            ],
        }),
        "Splat Regularize" | "Regularize" => Some(NodeHelpPage {
            name: "Splat Regularize",
            description: &[
                "Clamps splat parameters to a stable range and repairs invalid values.",
                "This reduces numerical drift after heavy edits or deformation.",
                "Normalize rotation re-orthonormalizes the quaternion so orientation stays valid.",
                "It is safe to keep in a pipeline as a stabilization step.",
            ],
            inputs: &["in: Splat geometry."],
            outputs: &["out: Regularized splats."],
            parameters: &[
                ("min_scale", "Minimum log-scale (ln sigma) to keep."),
                ("max_scale", "Maximum log-scale (ln sigma) to keep."),
                ("normalize_opacity", "Renormalize logit opacity to a stable range."),
                ("normalize_rotation", "Normalize/repair rotation quaternions."),
                ("remove_invalid", "Drop splats with NaN/Inf."),
            ],
        }),
        "Splat LOD" => Some(NodeHelpPage {
            name: "Splat LOD",
            description: &[
                "Reduces splat count by clustering splats into a voxel grid.",
                "Each occupied voxel produces one representative splat, preserving the overall shape.",
                "Smaller voxels retain detail; larger voxels are faster and more aggressive.",
                "An optional target count can further cap the output size.",
            ],
            inputs: &["in: Splat geometry."],
            outputs: &["out: Reduced splats."],
            parameters: &[
                ("voxel_size", "Voxel size in world units for clustering."),
                ("target_count", "Optional cap on output splats (0 disables)."),
            ],
        }),
        "Splat to Mesh" => Some(NodeHelpPage {
            name: "Splat to Mesh",
            description: &[
                "Converts splats to either a polygon mesh or an SDF volume.",
                "Density (Iso) voxelizes Gaussian density and extracts a surface with marching cubes.",
                "Ellipsoid (Smooth Min) blends analytic ellipsoids; it can be noisy for meshes but useful for SDFs.",
                "Use Output to choose Mesh or SDF Volume depending on downstream needs.",
            ],
            inputs: &["splats: Splat geometry."],
            outputs: &["out: Mesh or SDF volume."],
            parameters: &[
                ("output", "Output type: Mesh extracts a surface; SDF Volume outputs a signed distance grid."),
                ("algorithm", "Method: Density (Iso) uses a density grid; Ellipsoid (Smooth Min) blends ellipsoids."),
                ("voxel_size", "Base voxel size for the density grid (smaller = higher detail)."),
                ("voxel_size_max", "Maximum grid dimension; voxel size grows to fit this limit."),
                ("n_sigma", "Gaussian support radius in sigmas (larger = thicker, slower)."),
                ("density_iso", "Isovalue for Density (Iso) surface (Density only)."),
                ("surface_iso", "Ellipsoid surface threshold for Smooth Min method (Ellipsoid only)."),
                ("bounds_padding", "Padding around bounds in sigmas."),
                ("transfer_color", "Sample splat color and write to mesh Cd."),
                ("max_m2", "Exponent clamp to avoid overflow in ellipsoid evaluation (Ellipsoid only)."),
                ("smooth_k", "Smooth-min sharpness (higher = sharper union, Ellipsoid only)."),
                ("shell_radius", "Shell thickness for ellipsoid method (Ellipsoid only)."),
                ("blur_iters", "Blur passes on the density grid to smooth surfaces (Density only)."),
            ],
        }),
        "Splat Deform" => Some(NodeHelpPage {
            name: "Splat Deform",
            description: &[
                "Deforms a source splat model using a second input of edited points or splats.",
                "If the second input has matching splat count, positions map by index.",
                "Otherwise, points are consumed in order; extra points can create new splats when enabled.",
                "Derive rotation/scale estimates a local linear transform from neighbors to update orientation.",
            ],
            inputs: &["source: Original splats.", "deform: Edited point cloud or splats."],
            outputs: &["out: Deformed splats."],
            parameters: &[
                ("allow_new", "Allow new splats when target has more points; attributes are copied from nearest sources."),
                ("derive_rot_scale", "Infer rotation/scale from local deformation; disable to move centers only."),
            ],
        }),
        "Splat Delight" => Some(NodeHelpPage {
            name: "Splat Delight",
            description: &[
                "Removes baked lighting from splat SH coefficients to approximate albedo-like splats.",
                "Band 0 Only flattens to DC when you want a quick neutralization.",
                "SH Ratio divides each SH band by an estimated environment, preserving higher-frequency detail.",
                "Irradiance Divide estimates diffuse irradiance from SH and normals, then solves for per-splat albedo.",
                "Env Splat uses the second input as the environment (for delighting a cut-out from a larger scan).",
                "Uniform modes apply a constant environment; Custom uses the provided color.",
            ],
            inputs: &[
                "in: Splat geometry.",
                "env: Optional environment splats for Env Splat mode.",
            ],
            outputs: &["out: Delit splats."],
            parameters: &[
                ("delight_mode", "Mode: Band 0 Only, SH Ratio, Irradiance Divide, or Env Splat."),
                ("source_env", "Lighting source: From Splats, Uniform White, or Custom."),
                ("neutral_env", "Neutral target: Uniform White or Custom."),
                ("source_color", "Custom source lighting color (DC) when Source Env is Custom."),
                ("neutral_color", "Custom neutral color (DC) when Neutral Env is Custom."),
                ("eps", "Stability epsilon to avoid divide-by-zero."),
                ("ratio_min", "Minimum ratio clamp for SH Ratio mode."),
                ("ratio_max", "Maximum ratio clamp for SH Ratio mode."),
                ("high_band_gain", "Gain applied to higher SH bands."),
                ("output_sh_order", "Output SH order: L0, L1, L2, or L3."),
                ("albedo_max", "Maximum albedo clamp for Irradiance Divide."),
                ("group", "Optional group to restrict delighting."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "Splat Integrate" => Some(NodeHelpPage {
            name: "Splat Integrate",
            description: &[
                "Relights splats to match a target environment or a target splat set.",
                "From Splats modes use opacity-weighted averages; Uniform White gives neutral lighting.",
                "SH Ratio scales all SH bands to match the target environment.",
                "Diffuse replaces lighting using irradiance only (albedo-like relighting).",
                "Hybrid relights DC via irradiance and preserves or scales higher bands.",
                "Use the target splat input to transfer lighting from another scan.",
            ],
            inputs: &[
                "source: Splat geometry to relight.",
                "target: Optional target splats for lighting.",
            ],
            outputs: &["out: Relit splats."],
            parameters: &[
                ("relight_mode", "Mode: SH Ratio, Diffuse, or Hybrid."),
                ("source_env", "Source lighting: From Splats, Uniform White, or Custom."),
                ("target_env", "Target lighting: From Splats, Uniform White, or Custom."),
                ("source_color", "Custom source lighting color (DC) when Source Env is Custom."),
                ("target_color", "Custom target lighting color (DC) when Target Env is Custom."),
                ("eps", "Stability epsilon to avoid divide-by-zero."),
                ("ratio_min", "Minimum ratio clamp for SH Ratio mode."),
                ("ratio_max", "Maximum ratio clamp for SH Ratio mode."),
                ("high_band_gain", "Gain applied to higher SH bands."),
                ("high_band_mode", "High-band mode: Scale Only or Scale + Ratio."),
                ("output_sh_order", "Output SH order: L0, L1, L2, or L3."),
                ("albedo_max", "Maximum albedo clamp for Diffuse/Hybrid relighting."),
                ("group", "Optional group to restrict integration."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "Splat Heal" => Some(NodeHelpPage {
            name: "Splat Heal",
            description: &[
                "Fills holes in splat surfaces by generating new splats in under-dense regions.",
                "Voxel Close builds a density grid, performs morphological closing, then resplats missing surface voxels.",
                "SDF Patch evaluates an ellipsoid SDF band and places splats near the implied surface while skipping occupied voxels.",
                "Use Heal Bounds to limit work to a box or sphere; Preview Surface can output a debug mesh of the healed surface.",
            ],
            inputs: &["in: Splat geometry."],
            outputs: &["out: Healed splats (original + new)."],
            parameters: &[
                ("group", "Optional group to restrict healing."),
                ("group_type", "Group domain to use."),
                ("heal_shape", "Heal bounds: All, Box, or Sphere."),
                ("method", "Method: Voxel Close or SDF Patch."),
                ("voxel_size", "Voxel size for the density grid (smaller = more detail)."),
                ("voxel_size_max", "Maximum voxel dimension (safety clamp)."),
                ("n_sigma", "Gaussian support radius in sigmas."),
                ("density_iso", "Density threshold for occupancy."),
                ("bounds_padding", "Padding around bounds in sigmas."),
                ("close_radius", "Closing radius in voxels (Voxel Close only)."),
                ("fill_stride", "Subsample candidates (higher = fewer splats)."),
                ("max_new", "Maximum number of new splats."),
                ("sdf_band", "SDF band thickness around the surface (SDF Patch only)."),
                ("sdf_close", "SDF offset to close small gaps (SDF Patch only)."),
                ("search_radius", "Neighbor search radius for copying attributes (auto if <= 0)."),
                ("min_distance", "Minimum distance to existing splats (auto if <= 0)."),
                ("scale_mul", "Scale multiplier for new splats."),
                ("opacity_mul", "Opacity multiplier for new splats."),
                ("copy_sh", "Copy full SH coefficients (else DC only)."),
                ("preview_surface", "Preview the healed surface as a mesh."),
                ("max_m2", "Exponent clamp for SDF method (SDF Patch only)."),
                ("smooth_k", "Smooth-min blend sharpness (SDF Patch only)."),
                ("shell_radius", "Ellipsoid shell radius (SDF Patch only)."),
                ("blur_iters", "Density blur iterations (Voxel Close only)."),
            ],
        }),
        "Splat Outlier" => Some(NodeHelpPage {
            name: "Splat Outlier",
            description: &[
                "Removes stray splats by clustering in position space and discarding noise.",
                "The node runs a DBSCAN-style density pass and deletes splats that do not have enough neighbors.",
                "Use min_cluster_size to remove tiny clusters that float away from the main surface.",
                "Tweak eps and min_pts to control how aggressively it cleans sparse regions.",
            ],
            inputs: &["in: Splat geometry."],
            outputs: &["out: Splats with outliers removed."],
            parameters: &[
                ("group", "Optional group to restrict outlier removal."),
                ("group_type", "Group domain to use."),
                ("eps", "Neighborhood radius for clustering (<= 0 uses auto spacing)."),
                ("min_pts", "Minimum neighbors for a core splat."),
                ("min_cluster_size", "Remove clusters smaller than this size (0 disables)."),
            ],
        }),
        "Splat Cluster" => Some(NodeHelpPage {
            name: "Splat Cluster",
            description: &[
                "Assigns a cluster id to each splat for selection and downstream editing.",
                "Grid mode bins splats into spatial cells for fast, deterministic clustering.",
                "DBSCAN mode groups splats by local density and labels noise as -1.",
                "The cluster id is stored in the chosen attribute as an integer.",
            ],
            inputs: &["in: Splat geometry."],
            outputs: &["out: Splats with a cluster attribute."],
            parameters: &[
                ("group", "Optional group to restrict clustering."),
                ("group_type", "Group domain to use."),
                ("method", "Clustering method: Grid (fast) or DBSCAN (density-based)."),
                ("attr", "Attribute name to store the cluster id (integer)."),
                ("cell_size", "Grid cell size (<= 0 uses auto spacing)."),
                ("eps", "DBSCAN radius (<= 0 uses auto spacing)."),
                ("min_pts", "Minimum neighbors for a DBSCAN core."),
            ],
        }),
        "Splat Merge" => Some(NodeHelpPage {
            name: "Splat Merge",
            description: &[
                "Geometrically joins two splat models by softening their seam.",
                "Feather fades overlapping splats based on distance and blends the two inputs.",
                "Skirt generates new bridging splats between nearby pairs to fill gaps at the seam.",
                "Use seam parameters to control opacity, scale, and whether to use DC-only SH.",
            ],
            inputs: &["a: First splat model.", "b: Second splat model."],
            outputs: &["out: Merged splats."],
            parameters: &[
                ("method", "Join method: Feather or Skirt."),
                ("blend_radius", "Blend radius for feathering/fade (Feather mode)."),
                ("fade_originals", "Fade original splats near the seam."),
                ("skirt_max_dist", "Maximum distance to bridge with skirt splats (Skirt mode)."),
                ("skirt_step", "Spacing between skirt splats (Skirt mode)."),
                ("skirt_max_new", "Maximum skirt splats per pair (Skirt mode)."),
                ("seam_alpha", "Opacity for seam splats."),
                ("seam_scale", "Scale multiplier for seam splats."),
                ("seam_dc_only", "Use DC-only SH for seam splats."),
                ("preview_skirt", "Preview skirt geometry as wireframe when selected."),
            ],
        }),
        "Volume from Geometry" => Some(NodeHelpPage {
            name: "Volume from Geometry",
            description: &[
                "Voxelizes geometry into a regular grid volume.",
                "Density mode fills the interior with a constant density and smooth antialiasing at the boundary.",
                "SDF mode computes signed distance; grid resolution is derived from the max dimension parameter.",
            ],
            inputs: &["in: Geometry to voxelize."],
            outputs: &["out: Volume (density or SDF)."],
            parameters: &[
                ("mode", "Volume type: Density or SDF."),
                ("max_dim", "Largest voxel dimension (grid resolution)."),
                ("padding", "Padding around the bounds."),
                ("density_scale", "Density value inside the volume."),
                ("sdf_band", "SDF band width for rendering."),
            ],
        }),
        "Volume Combine" => Some(NodeHelpPage {
            name: "Volume Combine",
            description: &[
                "Combines two volumes into a single volume by resampling them onto a shared grid.",
                "Operators include add, subtract, multiply, min, max, and average for CSG-like workflows.",
                "Resolution mode picks whether the output grid matches the lower, higher, or average input resolution.",
            ],
            inputs: &["a: First volume.", "b: Second volume."],
            outputs: &["out: Combined volume."],
            parameters: &[
                ("op", "Operator: Add, Subtract, Multiply, Min, Max, or Average."),
                ("resolution", "Resolution: Lower, Higher, or Average."),
            ],
        }),
        "Volume Blur" => Some(NodeHelpPage {
            name: "Volume Blur",
            description: &[
                "Blurs volume values over a radius in world space.",
                "Multiple iterations approximate a smoother kernel for softer results.",
                "Use it to smooth density fields before meshing or compositing.",
            ],
            inputs: &["in: Volume to blur."],
            outputs: &["out: Blurred volume."],
            parameters: &[
                ("radius", "Blur radius in world units."),
                ("iterations", "Number of blur passes."),
            ],
        }),
        "Volume to Mesh" => Some(NodeHelpPage {
            name: "Volume to Mesh",
            description: &[
                "Extracts a surface from a volume using marching cubes.",
                "Density mode uses a density isovalue, while SDF mode uses an isosurface at 0.0.",
                "Use it to convert volume results back into polygon meshes.",
            ],
            inputs: &["in: Volume to convert."],
            outputs: &["out: Polygon mesh."],
            parameters: &[
                ("mode", "Mode: Density or SDF."),
                ("density_iso", "Isovalue for density surfaces."),
                ("surface_iso", "Isovalue for SDF surfaces."),
            ],
        }),
        "Group" => Some(NodeHelpPage {
            name: "Group",
            description: &[
                "Creates or updates a named group using a selection shape or attribute range.",
                "Groups can target point, vertex, or primitive domains and are used by many operators as masks.",
                "Selection mode enables interactive picking and box selection in the viewport.",
            ],
            inputs: &["in: Geometry to group."],
            outputs: &["out: Geometry with group data."],
            parameters: &[
                ("group", "Name of the group to create."),
                ("base_group", "Optional source group to filter first."),
                ("domain", "Group domain (vertex/point/primitive)."),
                ("shape", "Selection shape: Box, Sphere, Plane, Selection, or Attribute Range."),
                ("select_backface", "Allow selecting back-facing elements."),
                ("invert", "Invert selection (keep outside)."),
                ("center", "Shape center."),
                ("size", "Box size in X/Y/Z."),
                ("radius", "Sphere radius."),
                ("plane_origin", "Plane origin for half-space selection."),
                ("plane_normal", "Plane normal for half-space selection."),
                ("attr", "Attribute name for attribute-range selection."),
                ("attr_min", "Minimum attribute value to include."),
                ("attr_max", "Maximum attribute value to include."),
            ],
        }),
        "Transform" => Some(NodeHelpPage {
            name: "Transform",
            description: &[
                "Applies translation, rotation, and scale to geometry.",
                "The transform can be pivoted and restricted to a group mask.",
                "Meshes, curves, splats, and volumes are transformed consistently.",
            ],
            inputs: &["in: Geometry to transform."],
            outputs: &["out: Transformed geometry."],
            parameters: &[
                ("group", "Optional group to restrict transform."),
                ("group_type", "Group domain to use."),
                ("translate", "Translation in X/Y/Z."),
                ("rotate_deg", "Rotation in degrees (XYZ)."),
                ("scale", "Scale factors (XYZ)."),
                ("pivot", "Pivot point."),
            ],
        }),
        "FFD" => Some(NodeHelpPage {
            name: "FFD",
            description: &[
                "Free-form deformation (FFD) warps geometry through a 3D lattice of control points.",
                "Supply a lattice point cloud to the second input with res_x * res_y * res_z points; those points act as the cage.",
                "If no lattice input is provided, the node builds a regular lattice from the bounds, resulting in an identity deformation.",
            ],
            inputs: &[
                "in: Geometry to deform.",
                "lattice: Optional lattice point cloud (res_x * res_y * res_z points).",
            ],
            outputs: &["out: Deformed geometry."],
            parameters: &[
                ("group", "Optional group to restrict deformation."),
                ("group_type", "Group domain to use."),
                ("res_x", "Control points along X (lattice resolution)."),
                ("res_y", "Control points along Y (lattice resolution)."),
                ("res_z", "Control points along Z (lattice resolution)."),
                ("use_input_bounds", "Use input geometry bounds to define the lattice."),
                ("center", "Lattice center when not using input bounds."),
                ("size", "Lattice size when not using input bounds."),
                ("padding", "Expand lattice bounds by this amount."),
                ("extrapolate", "Allow extrapolation outside the lattice bounds."),
            ],
        }),
        "Copy/Transform" => Some(NodeHelpPage {
            name: "Copy/Transform",
            description: &[
                "Creates multiple copies by applying a base transform and per-copy increments.",
                "Use it for arrays, stacks, or patterned layouts without instancing.",
                "The base transform controls the first copy, and steps are applied per copy index.",
            ],
            inputs: &["in: Geometry to copy."],
            outputs: &["out: Merged copies."],
            parameters: &[
                ("count", "Number of copies."),
                ("translate", "Base translation for the first copy."),
                ("rotate_deg", "Base rotation for the first copy (degrees)."),
                ("scale", "Base scale for the first copy."),
                ("pivot", "Pivot point for the base transform."),
                ("translate_step", "Per-copy translation step."),
                ("rotate_step_deg", "Per-copy rotation step (degrees)."),
                ("scale_step", "Per-copy scale step."),
            ],
        }),
        "Merge" => Some(NodeHelpPage {
            name: "Merge",
            description: &[
                "Merges all incoming geometry streams into one output.",
                "Point pools and primitive arrays are concatenated and attributes are reconciled.",
                "Use this to recombine branches or add multiple sources together.",
            ],
            inputs: &["input0..n: Geometry to merge."],
            outputs: &["out: Merged geometry."],
            parameters: &[],
        }),
        "Copy to Points" => Some(NodeHelpPage {
            name: "Copy to Points",
            description: &[
                "Copies source meshes or splats onto each template point.",
                "Template normals can orient copies, and pscale scales each instance if present.",
                "When the template is splats, the splat centers act as the template points.",
                "Attributes can be inherited from the template and each copy can record its index.",
            ],
            inputs: &[
                "source: Mesh or splat geometry to copy.",
                "template: Points to place copies on (mesh points or splat centers).",
            ],
            outputs: &["out: Merged copies."],
            parameters: &[
                ("align_to_normals", "Align copies to template normals."),
                ("translate", "Translation applied to each copy."),
                ("rotate_deg", "Rotation applied to each copy (degrees)."),
                ("scale", "Scale applied to each copy."),
                ("inherit", "Template point attributes to inherit."),
                ("copy_attr", "Name of per-copy index attribute."),
                ("copy_attr_class", "Attribute class for copy index (Point/Vertex/Primitive)."),
                ("group", "Restrict to a template point group."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "Scatter" => Some(NodeHelpPage {
            name: "Scatter",
            description: &[
                "Scatters random points over surfaces, curves, or volumes.",
                "Volume density scales the scatter probability, and curve length or surface area drives uniformity.",
                "Use inherited attributes and density mapping to control distribution.",
            ],
            inputs: &["in: Geometry to scatter on."],
            outputs: &["out: Point geometry."],
            parameters: &[
                ("count", "Number of points to scatter."),
                ("seed", "Random seed."),
                ("density_attr", "Optional density attribute for weighting."),
                ("density_min", "Minimum mapped density value."),
                ("density_max", "Maximum mapped density value."),
                ("inherit", "Attributes to inherit from the source."),
                ("group", "Restrict scattering to a group."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "Normal" => Some(NodeHelpPage {
            name: "Normal",
            description: &[
                "Computes normals for meshes based on vertex angles.",
                "The angle threshold controls smoothing across hard edges.",
                "Use after deformation or topology changes for correct shading.",
            ],
            inputs: &["in: Mesh geometry."],
            outputs: &["out: Mesh with normals."],
            parameters: &[
                ("threshold_deg", "Angle threshold for smoothing."),
                ("group", "Restrict normal recompute to a group."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "Color" => Some(NodeHelpPage {
            name: "Color",
            description: &[
                "Writes or updates a color attribute (Cd).",
                "Constant mode writes a fixed color; Color from Attribute maps a float through a gradient.",
                "Use it for visualization, masks, or stylized coloring.",
            ],
            inputs: &["in: Geometry to color."],
            outputs: &["out: Colored geometry."],
            parameters: &[
                ("color_mode", "Mode: Constant or Color from Attribute."),
                ("color", "Constant color value (RGB)."),
                ("attr", "Attribute to map into the gradient."),
                ("gradient", "Gradient stops, e.g. 0:#000000;1:#ffffff."),
                ("domain", "Attribute domain to write."),
                ("group", "Restrict to a group."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "Noise/Mountain" => Some(NodeHelpPage {
            name: "Noise/Mountain",
            description: &[
                "Displaces points along their normals using fractal noise.",
                "This is a simple terrain-style operator that adds mid-frequency detail.",
                "Normals are recomputed after displacement for consistent shading.",
            ],
            inputs: &["in: Geometry to displace."],
            outputs: &["out: Displaced geometry."],
            parameters: &[
                ("amplitude", "Displacement strength."),
                ("frequency", "Noise frequency."),
                ("seed", "Noise seed."),
                ("offset", "Noise space offset."),
                ("group", "Restrict to a group."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "Erosion Noise" => Some(NodeHelpPage {
            name: "Erosion Noise",
            description: &[
                "Applies erosion-style noise to a height field stored on points.",
                "The implementation is based on a common procedural erosion shader and adds slope-aware branching.",
                "Optionally writes a mask attribute for downstream effects.",
            ],
            inputs: &["in: Geometry with height attribute."],
            outputs: &["out: Geometry with eroded height."],
            parameters: &[
                ("erosion_strength", "Height offset strength."),
                ("erosion_freq", "Erosion pattern frequency."),
                ("erosion_octaves", "Number of erosion octaves."),
                ("erosion_roughness", "Amplitude falloff per octave."),
                ("erosion_lacunarity", "Frequency growth per octave."),
                ("erosion_slope_strength", "Slope influence on flow."),
                ("erosion_branch_strength", "Branching influence on flow."),
                ("do_mask", "Write erosion mask to @mask."),
                ("group", "Restrict to a group."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "Smooth" => Some(NodeHelpPage {
            name: "Smooth",
            description: &[
                "Smooths attribute values across neighbors.",
                "World-space mode uses a radius in space; Surface mode uses mesh adjacency for geodesic-like smoothing.",
                "Use it to relax noise or even out attribute fields.",
            ],
            inputs: &["in: Geometry to smooth."],
            outputs: &["out: Smoothed geometry."],
            parameters: &[
                ("attr", "Attribute name(s) to smooth."),
                ("domain", "Attribute domain to smooth."),
                ("smooth_space", "Space: World or Surface."),
                ("radius", "Neighbor radius (0 = auto/1-ring)."),
                ("iterations", "Number of smoothing passes."),
                ("strength", "Blend strength per pass."),
                ("group", "Restrict to a group."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "UV Texture" => Some(NodeHelpPage {
            name: "UV Texture",
            description: &[
                "Generates UVs using simple projections.",
                "Planar projects onto an axis plane, Box projects six faces, Cylindrical wraps around an axis, and Spherical maps longitude/latitude.",
                "Scale and offset allow quick UV adjustments.",
            ],
            inputs: &["in: Mesh geometry."],
            outputs: &["out: Mesh with UVs."],
            parameters: &[
                ("projection", "Projection: Planar, Box, Cylindrical, or Spherical."),
                ("axis", "Primary axis for Planar/Cylindrical projections."),
                ("scale", "UV scale."),
                ("offset", "UV offset."),
            ],
        }),
        "UV Unwrap" => Some(NodeHelpPage {
            name: "UV Unwrap",
            description: &[
                "Builds UV islands by clustering triangles with similar normals.",
                "Each island is planar-projected and then packed into 0-1 space.",
                "This is a fast unwrap suitable for previews or simple assets.",
            ],
            inputs: &["in: Mesh geometry."],
            outputs: &["out: Mesh with UVs."],
            parameters: &[
                ("padding", "Island padding in UV space."),
                ("normal_threshold", "Angle threshold for island splits."),
            ],
        }),
        "UV View" => Some(NodeHelpPage {
            name: "UV View",
            description: &[
                "Displays a 2D wireframe of the incoming mesh UVs in the parameter pane.",
                "This node does not modify geometry and is meant for inspection.",
                "Use it downstream of UV Texture or UV Unwrap to verify layout.",
            ],
            inputs: &["in: Mesh geometry."],
            outputs: &["out: Pass-through geometry."],
            parameters: &[],
        }),
        "Material" => Some(NodeHelpPage {
            name: "Material",
            description: &[
                "Creates or updates a material and assigns it to primitives.",
                "The material is stored in geometry and referenced by a primitive 'material' attribute.",
                "Base color can be constant or sourced from a texture path.",
            ],
            inputs: &["in: Geometry to assign material to."],
            outputs: &["out: Geometry with material assignment."],
            parameters: &[
                ("name", "Material name."),
                ("base_color", "Base color (albedo)."),
                ("base_color_tex", "Texture path for base color."),
                ("metallic", "Metallic factor."),
                ("roughness", "Roughness factor."),
            ],
        }),
        "Ray" => Some(NodeHelpPage {
            name: "Ray",
            description: &[
                "Projects points onto target geometry using raycasts.",
                "Normal mode casts along point normals, Direction uses a fixed vector, and Closest finds the nearest hit.",
                "You can import attributes from the hit and optionally move points to the hit location.",
            ],
            inputs: &["in: Geometry to project.", "target: Geometry to hit."],
            outputs: &["out: Projected geometry."],
            parameters: &[
                ("method", "Ray mode: Normal, Direction, or Closest."),
                ("direction", "Ray direction (Direction mode)."),
                ("max_distance", "Maximum ray distance."),
                ("apply_transform", "Move points to hit location."),
                ("attr", "Attribute(s) to import from the hit."),
                ("hit_group", "Group name to mark hits."),
                ("group", "Restrict source points to a group."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "Attribute Noise" => Some(NodeHelpPage {
            name: "Attribute Noise",
            description: &[
                "Writes procedural noise into an attribute.",
                "Supports float/vec2/vec3 outputs and multiple noise bases.",
                "Use it for masks, variation, or driving downstream operations.",
            ],
            inputs: &["in: Geometry to modify."],
            outputs: &["out: Geometry with noise attribute."],
            parameters: &[
                ("attr", "Attribute name to write."),
                ("domain", "Attribute domain to write."),
                ("data_type", "Attribute type: Float, Vec2, or Vec3."),
                ("noise_type", "Noise basis: Value or Perlin."),
                ("amplitude", "Noise amplitude."),
                ("frequency", "Noise frequency."),
                ("offset", "Noise space offset."),
                ("seed", "Noise seed."),
                ("group", "Restrict to a group."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "Attribute from Feature" => Some(NodeHelpPage {
            name: "Attribute from Feature",
            description: &[
                "Computes simple geometric features such as area or gradient.",
                "The feature value is written to the chosen attribute domain.",
                "This provides fast feature extraction similar to a lightweight Measure SOP.",
            ],
            inputs: &["in: Geometry to analyze."],
            outputs: &["out: Geometry with feature attribute."],
            parameters: &[
                ("feature", "Feature: Area or Gradient."),
                ("attr", "Destination attribute name (empty = default)."),
                ("domain", "Attribute domain to write."),
                ("group", "Restrict to a group."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "Attribute from Volume" => Some(NodeHelpPage {
            name: "Attribute from Volume",
            description: &[
                "Samples a volume at geometry locations and stores the value in an attribute.",
                "This lets you drive geometry using density or SDF values.",
                "Works on point, vertex, or primitive domains.",
            ],
            inputs: &["in: Geometry to receive values.", "volume: Volume to sample."],
            outputs: &["out: Geometry with sampled attribute."],
            parameters: &[
                ("attr", "Attribute name (empty = volume name)."),
                ("domain", "Attribute domain to write."),
                ("group", "Restrict to a group."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "Attribute Transfer" => Some(NodeHelpPage {
            name: "Attribute Transfer",
            description: &[
                "Transfers attributes from a source input onto a target input.",
                "Values are sampled from the nearest source elements.",
                "Use it to copy color, masks, or metadata between geometries.",
            ],
            inputs: &["target: Geometry to receive attributes.", "source: Geometry providing attributes."],
            outputs: &["out: Geometry with transferred attributes."],
            parameters: &[
                ("attr", "Space-delimited list of attributes."),
                ("domain", "Attribute domain to transfer."),
                ("group", "Restrict to a group."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "Attribute Math" => Some(NodeHelpPage {
            name: "Attribute Math",
            description: &[
                "Applies a math operation to an attribute and writes the result.",
                "Operations include add, subtract, multiply, and divide.",
                "Use it for quick remapping or uniform scaling of attributes.",
            ],
            inputs: &["in: Geometry to modify."],
            outputs: &["out: Geometry with modified attributes."],
            parameters: &[
                ("attr", "Source attribute."),
                ("result", "Destination attribute."),
                ("domain", "Attribute domain to operate on."),
                ("op", "Operation: Add, Subtract, Multiply, or Divide."),
                ("value_f", "Scalar operand."),
                ("value_v3", "Vector operand."),
                ("group", "Restrict to a group."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "Wrangle" => Some(NodeHelpPage {
            name: "Wrangle",
            description: &[
                "Runs a small expression language to edit attributes directly.",
                "Supports implicit variables like @P, @ptnum/@primnum and query functions like point(), vertex(), prim(), splat(), and sample().",
                "A second input can be queried for attribute lookups or volume sampling, similar to Houdini wrangles.",
            ],
            inputs: &["in: Geometry to modify.", "input1: Optional secondary geometry/volume."],
            outputs: &["out: Modified geometry."],
            parameters: &[
                ("mode", "Execution domain: Point, Vertex, Primitive, or Detail."),
                ("code", "Wrangle code snippet."),
                ("group", "Restrict to a group."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "Output" => Some(NodeHelpPage {
            name: "Output",
            description: &[
                "Marks the final output of a graph branch.",
                "The node simply passes geometry through, but it is used by the UI to choose display and export.",
                "Use it to make pipelines explicit and easier to read.",
            ],
            inputs: &["in: Geometry to output."],
            outputs: &["out: Pass-through geometry."],
            parameters: &[],
        }),
        _ => None,
    }
}
