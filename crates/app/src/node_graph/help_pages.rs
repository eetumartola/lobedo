#[derive(Clone, Copy)]
pub struct NodeHelpPage {
    pub name: &'static str,
    pub description: &'static [&'static str],
    pub inputs: &'static [&'static str],
    pub outputs: &'static [&'static str],
    pub parameters: &'static [(&'static str, &'static str)],
}

mod help_pages_io;
mod help_pages_splats;
mod help_pages_volumes;

pub fn node_help_page(node_name: &str) -> Option<NodeHelpPage> {
    if let Some(page) = help_pages_splats::node_help_page(node_name) {
        return Some(page);
    }
    if let Some(page) = help_pages_volumes::node_help_page(node_name) {
        return Some(page);
    }
    if let Some(page) = help_pages_io::node_help_page(node_name) {
        return Some(page);
    }

    match node_name {
        "Box" => Some(NodeHelpPage {
            name: "Box",
            description: &[
                "Creates an axis-aligned box mesh centered at the given position.",
                "Use it for blockouts, quick boolean volumes, or as a reference size in the scene.",
                "The box is generated with shared points so downstream deformers and normals behave predictably.",
            ],
            inputs: &[],
            outputs: &["out: Mesh with box primitives."],
            parameters: &[
                ("size", "Box dimensions in X/Y/Z."),
                ("center", "Box center in world space."),
            ],
        }),
        "Grid" => Some(NodeHelpPage {
            name: "Grid",
            description: &[
                "Creates a flat grid mesh on the XZ plane (Y up).",
                "It is useful as a ground plane, UV test surface, or scatter source.",
                "Rows and columns control tessellation and downstream point density.",
            ],
            inputs: &[],
            outputs: &["out: Mesh grid."],
            parameters: &[
                ("size", "Grid size in X/Z."),
                ("rows", "Rows (subdivisions) along Z."),
                ("cols", "Columns (subdivisions) along X."),
                ("center", "Grid center in world space."),
            ],
        }),
        "Sphere" => Some(NodeHelpPage {
            name: "Sphere",
            description: &[
                "Creates a UV sphere mesh with poles at top and bottom.",
                "Row/column counts control tessellation and UV seam density.",
                "Use it for placeholders, smooth shapes, or as a deformation target.",
            ],
            inputs: &[],
            outputs: &["out: Mesh sphere."],
            parameters: &[
                ("radius", "Sphere radius."),
                ("rows", "Latitude segments."),
                ("cols", "Longitude segments."),
                ("center", "Sphere center in world space."),
            ],
        }),
        "Tube" => Some(NodeHelpPage {
            name: "Tube",
            description: &[
                "Creates a vertical tube/cylinder along the Y axis.",
                "It can be capped or left open depending on your use case.",
                "Row/column counts control tessellation along height and around the circumference.",
            ],
            inputs: &[],
            outputs: &["out: Mesh tube."],
            parameters: &[
                ("radius", "Tube radius."),
                ("height", "Tube height."),
                ("rows", "Height segments."),
                ("cols", "Side segments."),
                ("capped", "Add caps at the ends."),
                ("center", "Tube center in world space."),
            ],
        }),
        "Circle" => Some(NodeHelpPage {
            name: "Circle",
            description: &[
                "Creates a circle primitive on the XZ plane.",
                "Curve mode outputs a closed polyline; Mesh mode outputs a triangulated disk.",
                "Use it as a sweep profile, a planar shape, or a curve source.",
            ],
            inputs: &[],
            outputs: &["out: Curve or mesh circle."],
            parameters: &[
                ("output", "Output mode: Curve or Mesh."),
                ("radius", "Circle radius."),
                ("segments", "Number of segments."),
                ("center", "Circle center in world space."),
            ],
        }),
        "Curve" => Some(NodeHelpPage {
            name: "Curve",
            description: &[
                "Creates a polyline curve from a list of points.",
                "Curve points live in the shared point pool so they can be edited like any other points.",
                "Subdivisions insert extra points between controls for smoother downstream results.",
            ],
            inputs: &[],
            outputs: &["out: Curve primitive referencing points."],
            parameters: &[
                ("points", "Curve points encoded as x y z; x y z; ..."),
                ("subdivs", "Subdivisions per segment for smoothing."),
                ("closed", "Close the curve loop."),
            ],
        }),
        "Boolean" | "Boolean SDF" => Some(NodeHelpPage {
            name: "Boolean SDF",
            description: &[
                "Combines meshes using signed distance fields (SDFs) and extracts a new surface.",
                "Mesh-Mesh mode converts both inputs to SDFs and performs the boolean in volume space.",
                "Mesh-SDF mode uses the SDF volume on input B as the cutting tool.",
                "The result is a triangulated surface from the combined SDF, which is robust but not topology-preserving.",
            ],
            inputs: &[
                "a: Mesh geometry to keep/modify.",
                "b: Mesh or SDF volume used as the cutter.",
            ],
            outputs: &["out: Booleaned mesh (other primitives pass through)."],
            parameters: &[
                ("mode", "Auto picks Mesh-Mesh unless input B has an SDF volume; Mesh-SDF forces using an SDF volume."),
                ("op", "Operation: Union, Difference (A - B), or Intersect."),
                ("max_dim", "Maximum voxel dimension used for the SDF grid."),
                ("padding", "Extra padding added around the combined bounds."),
                ("surface_iso", "Isovalue used when extracting the mesh from the SDF."),
            ],
        }),
        "Boolean Geo" => Some(NodeHelpPage {
            name: "Boolean Geo",
            description: &[
                "Combines meshes using polygonal booleans and preserves the original surface geometry where possible.",
                "Mesh-Mesh mode runs a manifold boolean and interpolates attributes from the source surfaces.",
                "Mesh-SDF mode clips the mesh against an SDF volume while keeping the input mesh triangles (no remeshing).",
                "Use it when you need attribute fidelity or topology that follows the original mesh.",
            ],
            inputs: &[
                "a: Mesh geometry to keep/modify.",
                "b: Mesh or SDF volume used as the cutter.",
            ],
            outputs: &["out: Booleaned mesh (other primitives pass through)."],
            parameters: &[
                ("mode", "Auto picks Mesh-Mesh unless input B has an SDF volume; Mesh-SDF forces using an SDF volume."),
                ("op", "Operation: Union, Difference (A - B), or Intersect."),
            ],
        }),
        "Sweep" => Some(NodeHelpPage {
            name: "Sweep",
            description: &[
                "Sweeps a profile curve or point list along a path curve to create a surface.",
                "The node builds an oriented frame along the path using the up vector, similar to a simple Frenet frame.",
                "If the inputs are plain point clouds, the closed flags decide whether each loop is closed.",
            ],
            inputs: &[
                "profile: Curve or mesh points to sweep.",
                "path: Curve or mesh points for the sweep path.",
            ],
            outputs: &["out: Swept polygon mesh."],
            parameters: &[
                ("profile_closed", "Close the profile if no curve primitive is supplied."),
                ("path_closed", "Close the path if no curve primitive is supplied."),
                ("up", "Up vector used to stabilize the sweep orientation."),
            ],
        }),
        "Delete" => Some(NodeHelpPage {
            name: "Delete",
            description: &[
                "Deletes geometry inside a selection volume, similar to Houdini Delete.",
                "For meshes, a triangle is kept only if all its points survive the test.",
                "Works on meshes, curves, and splats; groups can restrict the operation.",
            ],
            inputs: &["in: Geometry to delete from."],
            outputs: &["out: Filtered geometry."],
            parameters: &[
                ("shape", "Selection shape: Box, Sphere, Plane, Selection, or Attribute Range."),
                ("invert", "Invert selection (delete outside instead of inside)."),
                ("center", "Shape center."),
                ("size", "Box size in X/Y/Z."),
                ("radius", "Sphere radius."),
                ("plane_origin", "Plane origin for half-space delete."),
                ("plane_normal", "Plane normal for half-space delete."),
                ("group", "Optional group to restrict deletion."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "Group" => Some(NodeHelpPage {
            name: "Group",
            description: &[
                "Creates or updates a named group using a selection shape or attribute range.",
                "Groups can target point, vertex, or primitive domains and are used by many operators as masks.",
                "Selection mode enables interactive picking and box selection in the viewport.",
            ],
            inputs: &["in: Geometry to group."],
            outputs: &["out: Geometry with group data."],
            parameters: &[
                ("group", "Name of the group to create."),
                ("base_group", "Optional source group to filter first."),
                ("domain", "Group domain (vertex/point/primitive)."),
                ("shape", "Selection shape: Box, Sphere, Plane, Selection, or Attribute Range."),
                ("select_backface", "Allow selecting back-facing elements."),
                ("invert", "Invert selection (keep outside)."),
                ("center", "Shape center."),
                ("size", "Box size in X/Y/Z."),
                ("radius", "Sphere radius."),
                ("plane_origin", "Plane origin for half-space selection."),
                ("plane_normal", "Plane normal for half-space selection."),
                ("attr", "Attribute name for attribute-range selection."),
                ("attr_min", "Minimum attribute value to include."),
                ("attr_max", "Maximum attribute value to include."),
            ],
        }),
        "Group Expand" => Some(NodeHelpPage {
            name: "Group Expand",
            description: &[
                "Expands or contracts an existing group by walking topological neighbors.",
                "Expand adds adjacent elements; Contract removes boundary elements.",
                "Use it to grow/shrink selections without recreating them.",
            ],
            inputs: &["in: Geometry with the source group."],
            outputs: &["out: Geometry with the expanded group."],
            parameters: &[
                ("group", "Source group expression to expand/contract."),
                ("out_group", "Output group name (leave empty to overwrite simple names)."),
                ("group_type", "Group domain to use."),
                ("expand_mode", "Expand or Contract."),
                ("iterations", "Number of expansion steps."),
            ],
        }),
        "Transform" => Some(NodeHelpPage {
            name: "Transform",
            description: &[
                "Applies translation, rotation, and scale to geometry.",
                "The transform can be pivoted and restricted to a group mask.",
                "Meshes, curves, splats, and volumes are transformed consistently.",
            ],
            inputs: &["in: Geometry to transform."],
            outputs: &["out: Transformed geometry."],
            parameters: &[
                ("group", "Optional group to restrict transform."),
                ("group_type", "Group domain to use."),
                ("translate", "Translation in X/Y/Z."),
                ("rotate_deg", "Rotation in degrees (XYZ)."),
                ("scale", "Scale factors (XYZ)."),
                ("pivot", "Pivot point."),
            ],
        }),
        "FFD" => Some(NodeHelpPage {
            name: "FFD",
            description: &[
                "Free-form deformation (FFD) warps geometry through a 3D lattice of control points.",
                "Supply a lattice point cloud to the second input with res_x * res_y * res_z points; those points act as the cage.",
                "If no lattice input is provided, the node builds a regular lattice from the bounds, resulting in an identity deformation.",
            ],
            inputs: &[
                "in: Geometry to deform.",
                "lattice: Optional lattice point cloud (res_x * res_y * res_z points).",
            ],
            outputs: &["out: Deformed geometry."],
            parameters: &[
                ("group", "Optional group to restrict deformation."),
                ("group_type", "Group domain to use."),
                ("res_x", "Control points along X (lattice resolution)."),
                ("res_y", "Control points along Y (lattice resolution)."),
                ("res_z", "Control points along Z (lattice resolution)."),
                ("use_input_bounds", "Use input geometry bounds to define the lattice."),
                ("center", "Lattice center when not using input bounds."),
                ("size", "Lattice size when not using input bounds."),
                ("padding", "Expand lattice bounds by this amount."),
                ("extrapolate", "Allow extrapolation outside the lattice bounds."),
            ],
        }),
        "Copy/Transform" => Some(NodeHelpPage {
            name: "Copy/Transform",
            description: &[
                "Creates multiple copies by applying a base transform and per-copy increments.",
                "Use it for arrays, stacks, or patterned layouts without instancing.",
                "The base transform controls the first copy, and steps are applied per copy index.",
            ],
            inputs: &["in: Geometry to copy."],
            outputs: &["out: Merged copies."],
            parameters: &[
                ("count", "Number of copies."),
                ("translate", "Base translation for the first copy."),
                ("rotate_deg", "Base rotation for the first copy (degrees)."),
                ("scale", "Base scale for the first copy."),
                ("pivot", "Pivot point for the base transform."),
                ("translate_step", "Per-copy translation step."),
                ("rotate_step_deg", "Per-copy rotation step (degrees)."),
                ("scale_step", "Per-copy scale step."),
            ],
        }),
        "Merge" => Some(NodeHelpPage {
            name: "Merge",
            description: &[
                "Merges all incoming geometry streams into one output.",
                "Point pools and primitive arrays are concatenated and attributes are reconciled.",
                "Use this to recombine branches or add multiple sources together.",
            ],
            inputs: &["input0..n: Geometry to merge."],
            outputs: &["out: Merged geometry."],
            parameters: &[],
        }),
        "Copy to Points" => Some(NodeHelpPage {
            name: "Copy to Points",
            description: &[
                "Copies source meshes or splats onto each template point.",
                "Template normals can orient copies, and pscale scales each instance if present.",
                "When the template is splats, the splat centers act as the template points.",
                "Attributes can be inherited from the template and each copy can record its index.",
            ],
            inputs: &[
                "source: Mesh or splat geometry to copy.",
                "template: Points to place copies on (mesh points or splat centers).",
            ],
            outputs: &["out: Merged copies."],
            parameters: &[
                ("align_to_normals", "Align copies to template normals."),
                ("translate", "Translation applied to each copy."),
                ("rotate_deg", "Rotation applied to each copy (degrees)."),
                ("scale", "Scale applied to each copy."),
                ("inherit", "Template point attributes to inherit."),
                ("copy_attr", "Name of per-copy index attribute."),
                ("copy_attr_class", "Attribute class for copy index (Point/Vertex/Primitive)."),
                ("group", "Restrict to a template point group."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "Scatter" => Some(NodeHelpPage {
            name: "Scatter",
            description: &[
                "Scatters random points over surfaces, curves, or volumes.",
                "Volume density scales the scatter probability, and curve length or surface area drives uniformity.",
                "Use inherited attributes and density mapping to control distribution.",
            ],
            inputs: &["in: Geometry to scatter on."],
            outputs: &["out: Point geometry."],
            parameters: &[
                ("count", "Number of points to scatter."),
                ("seed", "Random seed."),
                ("density_attr", "Optional density attribute for weighting."),
                ("density_min", "Minimum mapped density value."),
                ("density_max", "Maximum mapped density value."),
                ("inherit", "Attributes to inherit from the source."),
                ("group", "Restrict scattering to a group."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "Normal" => Some(NodeHelpPage {
            name: "Normal",
            description: &[
                "Computes normals for meshes based on vertex angles.",
                "The angle threshold controls smoothing across hard edges.",
                "Use after deformation or topology changes for correct shading.",
            ],
            inputs: &["in: Mesh geometry."],
            outputs: &["out: Mesh with normals."],
            parameters: &[
                ("threshold_deg", "Angle threshold for smoothing."),
                ("group", "Restrict normal recompute to a group."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "PolyFrame" => Some(NodeHelpPage {
            name: "PolyFrame",
            description: &[
                "Builds a local frame (normal, tangent, bitangent) for points that belong to polygons or curves.",
                "Tangents are estimated from polygon edges and polyline directions, while curvature (difference of incoming/outgoing directions) drives the bitangent.",
                "The normal is computed as the cross product of tangent and bitangent, giving a stable frame along curves.",
                "Unconnected points (no attached primitives) fall back to world axes, ensuring stable output for isolated points.",
            ],
            inputs: &["in: Mesh geometry."],
            outputs: &["out: Mesh with frame attributes."],
            parameters: &[
                ("group", "Restrict frame computation to a point group."),
                ("group_type", "Group domain to use."),
                ("normal", "Name of the normal attribute to write."),
                ("tangent", "Name of the tangent attribute to write."),
                ("bitangent", "Name of the bitangent attribute to write."),
                (
                    "coherent",
                    "Keep bitangent direction coherent along curves to avoid flips when curvature changes sign.",
                ),
            ],
        }),
        "Color" => Some(NodeHelpPage {
            name: "Color",
            description: &[
                "Writes or updates a color attribute (Cd).",
                "Constant mode writes a fixed color; Color from Attribute maps a float through a gradient.",
                "Use it for visualization, masks, or stylized coloring.",
            ],
            inputs: &["in: Geometry to color."],
            outputs: &["out: Colored geometry."],
            parameters: &[
                ("color_mode", "Mode: Constant or Color from Attribute."),
                ("color", "Constant color value (RGB)."),
                ("attr", "Attribute to map into the gradient."),
                ("gradient", "Gradient stops, e.g. 0:#000000;1:#ffffff."),
                ("domain", "Attribute domain to write."),
                ("group", "Restrict to a group."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "Noise/Mountain" => Some(NodeHelpPage {
            name: "Noise/Mountain",
            description: &[
                "Displaces points along their normals using fractal noise.",
                "This is a simple terrain-style operator that adds mid-frequency detail.",
                "Normals are recomputed after displacement for consistent shading.",
            ],
            inputs: &["in: Geometry to displace."],
            outputs: &["out: Displaced geometry."],
            parameters: &[
                ("amplitude", "Displacement strength."),
                ("frequency", "Noise frequency."),
                ("seed", "Noise seed."),
                ("offset", "Noise space offset."),
                ("group", "Restrict to a group."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "Erosion Noise" => Some(NodeHelpPage {
            name: "Erosion Noise",
            description: &[
                "Applies erosion-style noise to a height field stored on points.",
                "The implementation is based on a common procedural erosion shader and adds slope-aware branching.",
                "Optionally writes a mask attribute for downstream effects.",
            ],
            inputs: &["in: Geometry with height attribute."],
            outputs: &["out: Geometry with eroded height."],
            parameters: &[
                ("erosion_strength", "Height offset strength."),
                ("erosion_freq", "Erosion pattern frequency."),
                ("erosion_octaves", "Number of erosion octaves."),
                ("erosion_roughness", "Amplitude falloff per octave."),
                ("erosion_lacunarity", "Frequency growth per octave."),
                ("erosion_slope_strength", "Slope influence on flow."),
                ("erosion_branch_strength", "Branching influence on flow."),
                ("do_mask", "Write erosion mask to @mask."),
                ("group", "Restrict to a group."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "Smooth" => Some(NodeHelpPage {
            name: "Smooth",
            description: &[
                "Smooths attribute values across neighbors.",
                "World-space mode uses a radius in space; Surface mode uses mesh adjacency for geodesic-like smoothing.",
                "Use it to relax noise or even out attribute fields.",
            ],
            inputs: &["in: Geometry to smooth."],
            outputs: &["out: Smoothed geometry."],
            parameters: &[
                ("attr", "Attribute name(s) to smooth."),
                ("domain", "Attribute domain to smooth."),
                ("smooth_space", "Space: World or Surface."),
                ("radius", "Neighbor radius (0 = auto/1-ring)."),
                ("iterations", "Number of smoothing passes."),
                ("strength", "Blend strength per pass."),
                ("group", "Restrict to a group."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "Resample" => Some(NodeHelpPage {
            name: "Resample",
            description: &[
                "Resamples geometry based on primitive type.",
                "Meshes are reduced with a simple voxel clustering pass to approximate the target triangle ratio.",
                "Curves are resampled to a fixed point count along arc length.",
                "Volumes are resampled to a new grid resolution while preserving world size.",
            ],
            inputs: &["in: Geometry to resample."],
            outputs: &["out: Resampled geometry."],
            parameters: &[
                ("curve_points", "Target number of points per curve."),
                ("mesh_ratio", "Target mesh triangle ratio (0-1)."),
                ("volume_max_dim", "Maximum voxel dimension for volume resampling."),
            ],
        }),
        "UV Texture" => Some(NodeHelpPage {
            name: "UV Texture",
            description: &[
                "Generates UVs using simple projections.",
                "Planar projects onto an axis plane, Box projects six faces, Cylindrical wraps around an axis, and Spherical maps longitude/latitude.",
                "Scale and offset allow quick UV adjustments.",
            ],
            inputs: &["in: Mesh geometry."],
            outputs: &["out: Mesh with UVs."],
            parameters: &[
                ("projection", "Projection: Planar, Box, Cylindrical, or Spherical."),
                ("axis", "Primary axis for Planar/Cylindrical projections."),
                ("scale", "UV scale."),
                ("offset", "UV offset."),
            ],
        }),
        "UV Unwrap" => Some(NodeHelpPage {
            name: "UV Unwrap",
            description: &[
                "Builds UV islands by clustering triangles with similar normals.",
                "Each island is planar-projected and then packed into 0-1 space.",
                "This is a fast unwrap suitable for previews or simple assets.",
            ],
            inputs: &["in: Mesh geometry."],
            outputs: &["out: Mesh with UVs."],
            parameters: &[
                ("padding", "Island padding in UV space."),
                ("normal_threshold", "Angle threshold for island splits."),
            ],
        }),
        "UV View" => Some(NodeHelpPage {
            name: "UV View",
            description: &[
                "Displays a 2D wireframe of the incoming mesh UVs in the parameter pane.",
                "This node does not modify geometry and is meant for inspection.",
                "Use it downstream of UV Texture or UV Unwrap to verify layout.",
            ],
            inputs: &["in: Mesh geometry."],
            outputs: &["out: Pass-through geometry."],
            parameters: &[],
        }),
        "Material" => Some(NodeHelpPage {
            name: "Material",
            description: &[
                "Creates or updates a material and assigns it to primitives.",
                "The material is stored in geometry and referenced by a primitive 'material' attribute.",
                "Base color can be constant or sourced from a texture path or URL.",
            ],
            inputs: &["in: Geometry to assign material to."],
            outputs: &["out: Geometry with material assignment."],
            parameters: &[
                ("name", "Material name."),
                ("base_color", "Base color (albedo)."),
                ("base_color_tex", "Texture path or URL for base color."),
                ("metallic", "Metallic factor."),
                ("roughness", "Roughness factor."),
            ],
        }),
        "Ray" => Some(NodeHelpPage {
            name: "Ray",
            description: &[
                "Projects points onto target geometry using raycasts.",
                "Normal mode casts along point normals, Direction uses a fixed vector, and Closest finds the nearest hit.",
                "You can import attributes from the hit and optionally move points to the hit location.",
            ],
            inputs: &["in: Geometry to project.", "target: Geometry to hit."],
            outputs: &["out: Projected geometry."],
            parameters: &[
                ("method", "Ray mode: Normal, Direction, or Closest."),
                ("direction", "Ray direction (Direction mode)."),
                ("max_distance", "Maximum ray distance."),
                (
                    "splat_density",
                    "If > 0, rays into splats accumulate density until this threshold is reached.",
                ),
                ("apply_transform", "Move points to hit location."),
                ("attr", "Attribute(s) to import from the hit."),
                ("hit_group", "Group name to mark hits."),
                ("group", "Restrict source points to a group."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "Attribute Noise" => Some(NodeHelpPage {
            name: "Attribute Noise",
            description: &[
                "Writes procedural noise into an attribute.",
                "Supports float/vec2/vec3 outputs and multiple noise bases.",
                "Use it for masks, variation, or driving downstream operations.",
            ],
            inputs: &["in: Geometry to modify."],
            outputs: &["out: Geometry with noise attribute."],
            parameters: &[
                ("attr", "Attribute name to write."),
                ("domain", "Attribute domain to write."),
                ("data_type", "Attribute type: Float, Vec2, or Vec3."),
                ("noise_type", "Noise basis: Value or Perlin."),
                ("amplitude", "Noise amplitude."),
                ("frequency", "Noise frequency."),
                ("offset", "Noise space offset."),
                ("seed", "Noise seed."),
                ("group", "Restrict to a group."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "Attribute Expand" => Some(NodeHelpPage {
            name: "Attribute Expand",
            description: &[
                "Expands or contracts attribute values across the mesh topology.",
                "Expand behaves like a dilation (max of neighbors), while Contract is an erosion (min of neighbors).",
                "Useful for growing masks, widening color regions, or shrinking scalar fields.",
            ],
            inputs: &["in: Geometry with the attribute to edit."],
            outputs: &["out: Geometry with expanded/contracted attributes."],
            parameters: &[
                ("group", "Optional group to restrict edits."),
                ("group_type", "Group domain to use."),
                ("attr", "Attribute name to expand/contract."),
                ("domain", "Attribute domain to operate on."),
                ("expand_mode", "Expand or Contract."),
                ("iterations", "Number of expansion steps."),
            ],
        }),
        "Attribute Promote" => Some(NodeHelpPage {
            name: "Attribute Promote",
            description: &[
                "Promotes or demotes attributes between classes (point/vertex/primitive/detail).",
                "Use this to collapse data (point -> primitive) or distribute it (primitive -> point) using merge rules.",
                "Optional piece attributes allow promoting per-piece so each piece keeps its own values and even allow same-class promotions.",
                "For string attributes, Average behaves like Median and Sum concatenates; other numeric methods fall back to First.",
            ],
            inputs: &["in: Geometry with the source attribute."],
            outputs: &["out: Geometry with the promoted attribute."],
            parameters: &[
                ("attr", "Original attribute name or pattern."),
                ("source_domain", "Original class to read from."),
                ("target_domain", "New class to write to."),
                ("piece_attr", "Optional piece attribute (int or string) to promote per-piece."),
                ("promotion", "Merge rule: Max/Min/Average/Mode/Median/Sum/Sum of Squares/RMS/First/Last."),
                ("rename", "Enable renaming the promoted attribute."),
                ("new_name", "New attribute name or pattern (* placeholder)."),
                ("delete_original", "Remove the source attribute after promoting."),
            ],
        }),
        "Attribute from Feature" => Some(NodeHelpPage {
            name: "Attribute from Feature",
            description: &[
                "Computes simple geometric features such as area or gradient.",
                "The feature value is written to the chosen attribute domain.",
                "This provides fast feature extraction similar to a lightweight Measure SOP.",
            ],
            inputs: &["in: Geometry to analyze."],
            outputs: &["out: Geometry with feature attribute."],
            parameters: &[
                ("feature", "Feature: Area or Gradient."),
                ("attr", "Destination attribute name (empty = default)."),
                ("domain", "Attribute domain to write."),
                ("group", "Restrict to a group."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "Attribute from Volume" => Some(NodeHelpPage {
            name: "Attribute from Volume",
            description: &[
                "Samples a volume at geometry locations and stores the value in an attribute.",
                "This lets you drive geometry using density or SDF values.",
                "Works on point, vertex, or primitive domains.",
            ],
            inputs: &["in: Geometry to receive values.", "volume: Volume to sample."],
            outputs: &["out: Geometry with sampled attribute."],
            parameters: &[
                ("attr", "Attribute name (empty = volume name)."),
                ("domain", "Attribute domain to write."),
                ("group", "Restrict to a group."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "Attribute Transfer" => Some(NodeHelpPage {
            name: "Attribute Transfer",
            description: &[
                "Transfers attributes from a source input onto a target input.",
                "Values are sampled from the nearest source elements.",
                "Use it to copy color, masks, or metadata between geometries.",
            ],
            inputs: &["target: Geometry to receive attributes.", "source: Geometry providing attributes."],
            outputs: &["out: Geometry with transferred attributes."],
            parameters: &[
                ("attr", "Space-delimited list of attributes."),
                ("domain", "Attribute domain to transfer."),
                ("group", "Restrict to a group."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "Attribute Math" => Some(NodeHelpPage {
            name: "Attribute Math",
            description: &[
                "Applies a math operation to an attribute and writes the result.",
                "Operations include add, subtract, multiply, and divide.",
                "Use it for quick remapping or uniform scaling of attributes.",
            ],
            inputs: &["in: Geometry to modify."],
            outputs: &["out: Geometry with modified attributes."],
            parameters: &[
                ("attr", "Source attribute."),
                ("result", "Destination attribute."),
                ("domain", "Attribute domain to operate on."),
                ("op", "Operation: Add, Subtract, Multiply, or Divide."),
                ("value_f", "Scalar operand."),
                ("value_v3", "Vector operand."),
                ("group", "Restrict to a group."),
                ("group_type", "Group domain to use."),
            ],
        }),
        "Wrangle" => Some(NodeHelpPage {
            name: "Wrangle",
            description: &[
                "Runs a small expression language to edit attributes directly.",
                "Supports implicit variables like @P, @ptnum/@primnum and query functions like point(), vertex(), prim(), splat(), and sample().",
                "A second input can be queried for attribute lookups or volume sampling, similar to Houdini wrangles.",
            ],
            inputs: &["in: Geometry to modify.", "input1: Optional secondary geometry/volume."],
            outputs: &["out: Modified geometry."],
            parameters: &[
                ("mode", "Execution domain: Point, Vertex, Primitive, or Detail."),
                ("code", "Wrangle code snippet."),
                ("group", "Restrict to a group."),
                ("group_type", "Group domain to use."),
            ],
        }),
        _ => None,
    }
}
